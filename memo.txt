# やること
1. 辞書データ取り込み
 - データ読み込みと辞書インデクス生成
 - 別コンテキストで処理可能()
2. 対応表バッファ生成
 - パラメータ指定
3. 解答バッファ生成
 - パラメータは数列
4. グリッドの精査
 1. ファイル読み込み
 2. マトリックス生成
 3. 入力マス群生成(対応表との突き合わせ)
X. 解析

ナンクロ解析

---------メモ
■データモデル
- ナンクロの『各入力マス群』は『参照リスト』であり、これの群がナンクロのマトリックスとなる。
- 『参照リスト』の参照先は『空欄のある対応表』であり、これの組み合わせは『辞書に存在する文字列』になる。
- 上記２項より、空欄が埋まると他の『参照リスト』にデータが伝搬する。

■前準備
- 入力マス群の生成
 * 縦横で操作し、2つ以上連続する入力欄を『入力マス群』と扱う。

■解法
- 対応表テーブルと、その組み合わせ(各要素は双方向リストになるはず)を定義
- 各要素の文字が埋まっている率を開封率とし、開封率の高い組み合わせからキーワード合わせ
  例) ３文字目にアがある４文字の入力マス群の場合
  既に埋まっているので　LENGTH(KEYWORD) = 4 AND ( KEYWORD LIKE '__ア_' OR KEYWORD LIKE '_ア__' ) 的な条件で検索を行う。
  →最適化のポイントはここになる。
  →動的にここのデータを最適化することも可能。
  ちなみに、上記は記述例。この他にヒントがある場合は、それも加味する。
- 後は、キーワードをあわせるたびに各要素の開封率算出、開封率順にソート、キーワード検索を繰り返す
  →この処理で前述の検索処理が大幅に削減できる
- 伝搬先入力マス群から検索するようにすれば、最短になる(データが動いていない入力マス群で検索しても変化が発生しないため)

■辞書の取り扱い(インデクシング)
- 文字列のツリーを生成してもルートからの検索のほうが少ないため、あまり効率は良くない
- むしろ『何番目の文字がXXという文字列群』という管理をするほうが効率は良く、そこからのツリーを生成するのが良い認識
- 入力マス群に絶対に当てはまらないキーワード(長さミスマッチ)は最初から辞書には加えない
- 実は一番取り扱いが容易になるのは『DBに入れてしまうこと』。
  LIKEで検索すれば良いため。ただし、先頭が任意の文字になるとFULLSCANが発生する。

最短で『対応表からの抜粋によるキーワード』を求める方法は無い。
全てのマスを埋めること以外に『その解答が正しいのか』を確認する術が無いため。

また、結局は将棋と同じであるため、解法は無数に存在する。
よって、ここで手詰まりパターンを定義する。
- 残空欄リスト全てに、すべての残辞書データが当てはまらない場合
  本ロジックの基本的な思想として『すでに埋まっている箇所が多い入力マス群から埋める』ことになるため、
  『全く埋まっていない入力マス群』に対して解析を行った時点で手詰まりとなる。(将棋で言う負けパターン)
  よって、その時の最後の選択肢は一旦戻して再開する必要がある。